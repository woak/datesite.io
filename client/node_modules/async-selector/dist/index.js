'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function validateParams(params) {
    if ((typeof params === 'undefined' ? 'undefined' : _typeof(params)) !== 'object' || params === null) {
        throw new Error('An object of parameters must be passed in');
    }
    if (typeof params.async !== 'function') {
        throw new Error('Looking for a function called "async". This function returns a promise which handles asynchronous code');
    }
}

function hasChanged(oldValues, newValues) {
    if (oldValues === null) return true;
    if (oldValues.length !== newValues.length) return true;
    for (var i = 0; i < oldValues.length; i++) {
        if (newValues[i] !== oldValues[i]) {
            return true;
        }
    }
    return false;
}

function createResultObject(value, previous, isWaiting, isResolved, isRejected, omitStatus) {
    if (omitStatus) return value;
    return { value: value, previous: previous, isWaiting: isWaiting, isResolved: isResolved, isRejected: isRejected };
}

var emptyFunction = function emptyFunction() {};

function createAsyncSelector(params) {
    for (var _len = arguments.length, selectors = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        selectors[_key - 1] = arguments[_key];
    }

    validateParams(params);

    // if they passed in an array
    if (selectors.length === 1 && Array.isArray(selectors[0])) {
        selectors = selectors[0];
    }

    // User inputs
    var sync = params.sync,
        async = params.async,
        onReject = params.onReject,
        onResolve = params.onResolve,
        onCancel = params.onCancel,
        shouldUseAsync = params.shouldUseAsync,
        omitStatus = params.omitStatus,
        throttle = params.throttle;

    sync = typeof sync === 'function' ? sync : emptyFunction;
    onReject = typeof onReject === 'function' ? onReject : emptyFunction;
    onResolve = typeof onResolve === 'function' ? onResolve : emptyFunction;
    onCancel = typeof onCancel === 'function' ? onCancel : emptyFunction;
    shouldUseAsync = typeof shouldUseAsync === 'function' ? shouldUseAsync : function () {
        return true;
    };
    omitStatus = omitStatus === void 0 ? false : omitStatus;
    throttle = typeof throttle === 'function' ? throttle : null;

    //selector state
    var memoizedResult = null;
    var isPromisePending = false;
    var oldInputs = null;
    var oldPromise = null;
    var previousResolution = void 0;
    var f = null;

    var func = function func(state, props) {
        var forceUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var internal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        var mapped = selectors.map(function (f) {
            return f(state, props);
        });
        var changed = forceUpdate || hasChanged(oldInputs, mapped);
        if (changed) {
            /*  Handle throttling / debouncing if required */
            if (f !== null && internal === false) {
                f(state, props, forceUpdate);
                memoizedResult = createResultObject(sync.apply(undefined, _toConsumableArray(mapped)), previousResolution, true, false, false, omitStatus);
                return memoizedResult;
            }
            /* //////////////////////////////////////////// */

            if (isPromisePending) {
                onCancel.apply(undefined, [oldPromise].concat(_toConsumableArray(oldInputs)));
            }
            oldInputs = mapped;

            memoizedResult = createResultObject(sync.apply(undefined, _toConsumableArray(mapped)), previousResolution, true, false, false, omitStatus);

            if (!shouldUseAsync.apply(undefined, _toConsumableArray(mapped))) {
                return memoizedResult;
            }
            var promise = params.async.apply(params, _toConsumableArray(mapped));
            oldPromise = promise;
            isPromisePending = true;
            promise.then(function (promiseResolution) {
                if (!hasChanged(oldInputs, mapped)) {
                    previousResolution = promiseResolution;
                    isPromisePending = false;
                    memoizedResult = createResultObject(promiseResolution, previousResolution, false, true, false, omitStatus);
                    onResolve.apply(undefined, [promiseResolution].concat(_toConsumableArray(mapped)));
                }
            }).catch(function (promiseRejection) {
                if (!hasChanged(oldInputs, mapped)) {
                    isPromisePending = false;
                    memoizedResult = createResultObject(promiseRejection, previousResolution, false, false, true, omitStatus);
                    onReject.apply(undefined, [promiseRejection].concat(_toConsumableArray(mapped)));
                }
            });
        }
        // If the inputs didn't change, simply return the old memoized result
        return memoizedResult;
    };
    if (throttle !== null && f === null) {
        var throttled = throttle(function (state, props) {
            return func(state, props, true, true);
        });
        var old = null;
        f = function f(state, props) {
            var New = selectors.map(function (s) {
                return s(state, props);
            });
            if (hasChanged(old, New)) {
                old = New;
                throttled(state, props);
            }
        };
    }
    func.forceUpdate = function (state, props) {
        return func(state, props, true, false);
    };
    func.getResult = function () {
        return memoizedResult;
    };
    return func;
}

exports.default = createAsyncSelector;